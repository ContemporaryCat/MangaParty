// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAgent = `-- name: CreateAgent :exec
INSERT INTO mp_agent (id, contact_info, field_of_activity, language)
VALUES ($1, $2, $3, $4)
`

type CreateAgentParams struct {
	ID              pgtype.UUID `json:"id"`
	ContactInfo     []string    `json:"contact_info"`
	FieldOfActivity []string    `json:"field_of_activity"`
	Language        []string    `json:"language"`
}

func (q *Queries) CreateAgent(ctx context.Context, arg CreateAgentParams) error {
	_, err := q.db.Exec(ctx, createAgent,
		arg.ID,
		arg.ContactInfo,
		arg.FieldOfActivity,
		arg.Language,
	)
	return err
}

const createPerson = `-- name: CreatePerson :exec
INSERT INTO mp_person (id, profession)
VALUES ($1, $2)
`

type CreatePersonParams struct {
	ID         pgtype.UUID `json:"id"`
	Profession []string    `json:"profession"`
}

func (q *Queries) CreatePerson(ctx context.Context, arg CreatePersonParams) error {
	_, err := q.db.Exec(ctx, createPerson, arg.ID, arg.Profession)
	return err
}

const createRelationship = `-- name: CreateRelationship :one
INSERT INTO mp_relationship (source_id, target_id, rel_type, note)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateRelationshipParams struct {
	SourceID pgtype.UUID        `json:"source_id"`
	TargetID pgtype.UUID        `json:"target_id"`
	RelType  MpRelationshipType `json:"rel_type"`
	Note     pgtype.Text        `json:"note"`
}

func (q *Queries) CreateRelationship(ctx context.Context, arg CreateRelationshipParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createRelationship,
		arg.SourceID,
		arg.TargetID,
		arg.RelType,
		arg.Note,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const createRes = `-- name: CreateRes :one
INSERT INTO mp_res (entity_type, note)
VALUES ($1, $2)
RETURNING id, created_at
`

type CreateResParams struct {
	EntityType MpEntityType `json:"entity_type"`
	Note       []string     `json:"note"`
}

type CreateResRow struct {
	ID        pgtype.UUID        `json:"id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateRes(ctx context.Context, arg CreateResParams) (CreateResRow, error) {
	row := q.db.QueryRow(ctx, createRes, arg.EntityType, arg.Note)
	var i CreateResRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const createWork = `-- name: CreateWork :exec
INSERT INTO mp_work (id, category, representative_attributes)
VALUES ($1, $2, $3)
`

type CreateWorkParams struct {
	ID                       pgtype.UUID `json:"id"`
	Category                 []string    `json:"category"`
	RepresentativeAttributes []byte      `json:"representative_attributes"`
}

func (q *Queries) CreateWork(ctx context.Context, arg CreateWorkParams) error {
	_, err := q.db.Exec(ctx, createWork, arg.ID, arg.Category, arg.RepresentativeAttributes)
	return err
}

const getPerson = `-- name: GetPerson :one
SELECT 
    r.id, r.entity_type, r.note, r.created_at, r.updated_at,
    a.contact_info, a.field_of_activity, a.language,
    p.profession
FROM mp_res r
JOIN mp_agent a ON r.id = a.id
JOIN mp_person p ON a.id = p.id
WHERE r.id = $1
`

type GetPersonRow struct {
	ID              pgtype.UUID        `json:"id"`
	EntityType      MpEntityType       `json:"entity_type"`
	Note            []string           `json:"note"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	ContactInfo     []string           `json:"contact_info"`
	FieldOfActivity []string           `json:"field_of_activity"`
	Language        []string           `json:"language"`
	Profession      []string           `json:"profession"`
}

// Returns a fully hydrated Person by joining the inheritance tables
func (q *Queries) GetPerson(ctx context.Context, id pgtype.UUID) (GetPersonRow, error) {
	row := q.db.QueryRow(ctx, getPerson, id)
	var i GetPersonRow
	err := row.Scan(
		&i.ID,
		&i.EntityType,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ContactInfo,
		&i.FieldOfActivity,
		&i.Language,
		&i.Profession,
	)
	return i, err
}

const getWork = `-- name: GetWork :one
SELECT r.id, r.entity_type, r.note, r.created_at, w.category, w.representative_attributes
FROM mp_res r
JOIN mp_work w ON r.id = w.id
WHERE r.id = $1
`

type GetWorkRow struct {
	ID                       pgtype.UUID        `json:"id"`
	EntityType               MpEntityType       `json:"entity_type"`
	Note                     []string           `json:"note"`
	CreatedAt                pgtype.Timestamptz `json:"created_at"`
	Category                 []string           `json:"category"`
	RepresentativeAttributes []byte             `json:"representative_attributes"`
}

func (q *Queries) GetWork(ctx context.Context, id pgtype.UUID) (GetWorkRow, error) {
	row := q.db.QueryRow(ctx, getWork, id)
	var i GetWorkRow
	err := row.Scan(
		&i.ID,
		&i.EntityType,
		&i.Note,
		&i.CreatedAt,
		&i.Category,
		&i.RepresentativeAttributes,
	)
	return i, err
}

const getWorksByCreator = `-- name: GetWorksByCreator :many
SELECT 
    r.id, r.entity_type, r.note, r.created_at, w.category, w.representative_attributes
FROM mp_relationship rel
JOIN mp_res r ON rel.source_id = r.id
JOIN mp_work w ON r.id = w.id
WHERE rel.target_id = $1 -- The agent's ID
AND rel.rel_type = 'MP_R5'
`

type GetWorksByCreatorRow struct {
	ID                       pgtype.UUID        `json:"id"`
	EntityType               MpEntityType       `json:"entity_type"`
	Note                     []string           `json:"note"`
	CreatedAt                pgtype.Timestamptz `json:"created_at"`
	Category                 []string           `json:"category"`
	RepresentativeAttributes []byte             `json:"representative_attributes"`
}

// Demonstrates graph traversal: Find all works created by a specific person
func (q *Queries) GetWorksByCreator(ctx context.Context, targetID pgtype.UUID) ([]GetWorksByCreatorRow, error) {
	rows, err := q.db.Query(ctx, getWorksByCreator, targetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWorksByCreatorRow
	for rows.Next() {
		var i GetWorksByCreatorRow
		if err := rows.Scan(
			&i.ID,
			&i.EntityType,
			&i.Note,
			&i.CreatedAt,
			&i.Category,
			&i.RepresentativeAttributes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
